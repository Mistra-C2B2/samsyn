import { useCallback, useEffect, useReducer, useRef } from "react";
import type { Layer } from "../App";
import type { TerraDrawFeature } from "../components/MapView";

// ============================================================================
// Types
// ============================================================================

export type GeometryType = "Point" | "LineString" | "Polygon";
export type IconType = "default" | "anchor" | "ship" | "warning" | "circle";
export type LineStyle = "solid" | "dashed" | "dotted";

// GeoJSON Types
type GeoJSONCoordinates =
	| [number, number] // Point
	| [number, number][] // LineString
	| [number, number][][] // Polygon
	| [number, number][][][]; // MultiPolygon

interface GeoJSONGeometry {
	type: GeometryType;
	coordinates: GeoJSONCoordinates;
}

interface GeoJSONFeature {
	type: "Feature";
	geometry: GeoJSONGeometry;
	properties?: {
		name?: string;
		description?: string;
		icon?: string;
		lineStyle?: string;
		featureType?: string;
		[key: string]: unknown;
	};
}

interface GeoJSONFeatureCollection {
	type: "FeatureCollection";
	features: GeoJSONFeature[];
}

// ============================================================================
// Helper Functions
// ============================================================================

function isValidCoordinates(coords: unknown, type: GeometryType): boolean {
	if (coords === null || coords === undefined) return false;

	if (type === "Point") {
		if (!Array.isArray(coords) || coords.length < 2) return false;
		return (
			typeof coords[0] === "number" &&
			typeof coords[1] === "number" &&
			Number.isFinite(coords[0]) &&
			Number.isFinite(coords[1]) &&
			coords[0] >= -180 &&
			coords[0] <= 180 &&
			coords[1] >= -90 &&
			coords[1] <= 90
		);
	}

	if (type === "LineString") {
		if (!Array.isArray(coords) || coords.length < 2) return false;
		return coords.every((coord) => isValidCoordinates(coord, "Point"));
	}

	if (type === "Polygon") {
		if (!Array.isArray(coords) || coords.length === 0) return false;
		return coords.every(
			(ring) =>
				Array.isArray(ring) &&
				ring.length >= 4 &&
				ring.every((coord) => isValidCoordinates(coord, "Point")),
		);
	}

	return false;
}

// Metadata that we store in the reducer (NOT coordinates)
export interface FeatureMetadata {
	name: string;
	description: string;
	icon?: IconType;
	lineStyle?: LineStyle;
}

// Temporary feature data for features not yet in TerraDraw (during import/edit init)
export interface PendingFeature {
	id: string; // Temporary ID
	type: GeometryType;
	coordinates: GeoJSONCoordinates;
	metadata: FeatureMetadata;
}

// Full feature with geometry (merged from metadata + TerraDraw)
export interface Feature {
	id: string; // Unique ID for this feature (from TerraDraw)
	type: GeometryType;
	name: string;
	description: string;
	coordinates: GeoJSONCoordinates;
	icon?: IconType;
	lineStyle?: LineStyle;
}

export interface LayerEditorState {
	// Layer metadata
	layerName: string;
	category: string;
	description: string;
	layerColor: string;
	editableBy: "creator-only" | "everyone";

	// Feature metadata (geometry is in TerraDraw)
	featureMetadata: Map<string, FeatureMetadata>;

	// Pending features not yet in TerraDraw (during import/edit initialization)
	pendingFeatures: PendingFeature[];

	// UI state
	saving: boolean;
	error: string | null;

	// Edit mode tracking
	isEditMode: boolean;
	originalLayerId: string | null;
}

// ============================================================================
// Actions
// ============================================================================

type LayerEditorAction =
	| { type: "INITIALIZE"; payload: LayerEditorState }
	| { type: "SET_LAYER_NAME"; payload: string }
	| { type: "SET_CATEGORY"; payload: string }
	| { type: "SET_DESCRIPTION"; payload: string }
	| { type: "SET_LAYER_COLOR"; payload: string }
	| { type: "SET_EDITABLE_BY"; payload: "creator-only" | "everyone" }
	| {
			type: "ADD_FEATURE_METADATA";
			payload: { id: string; metadata: FeatureMetadata };
	  }
	| {
			type: "UPDATE_FEATURE_METADATA";
			payload: { id: string; updates: Partial<FeatureMetadata> };
	  }
	| { type: "REMOVE_FEATURE_METADATA"; payload: string }
	| { type: "CLEAR_FEATURES" }
	| { type: "SYNC_FROM_TERRADRAW"; payload: TerraDrawFeature[] }
	| { type: "IMPORT_GEOJSON"; payload: PendingFeature[] }
	| {
			type: "REMAP_FEATURE_IDS";
			payload: Array<{ oldId: string; newId: string }>;
	  }
	| { type: "CLEAR_PENDING_FEATURES" }
	| { type: "SET_SAVING"; payload: boolean }
	| { type: "SET_ERROR"; payload: string | null }
	| { type: "CLEAR_ERROR" }
	| { type: "RESET" };

// ============================================================================
// Initial State Factory
// ============================================================================

function createInitialState(editingLayer?: Layer | null): LayerEditorState {
	if (editingLayer) {
		// Extract features from the editing layer's GeoJSON data
		const layerData = editingLayer.data as GeoJSONFeatureCollection | undefined;

		// Create pending features (with geometry) until they're added to TerraDraw
		const pendingFeatures: PendingFeature[] = layerData?.features
			? layerData.features.map((feature) => ({
					id: crypto.randomUUID(), // Temporary ID (will be replaced when added to TerraDraw)
					type: feature.geometry.type,
					coordinates: feature.geometry.coordinates,
					metadata: {
						name: feature.properties?.name || "",
						description: feature.properties?.description || "",
						icon: (feature.properties?.icon as IconType) || "default",
						lineStyle: (feature.properties?.lineStyle as LineStyle) || "solid",
					},
				}))
			: [];

		return {
			layerName: editingLayer.name || "",
			category: editingLayer.category || "",
			description: editingLayer.description || "",
			layerColor: editingLayer.color || "#3b82f6",
			editableBy: editingLayer.editable || "creator-only",
			featureMetadata: new Map(),
			pendingFeatures,
			saving: false,
			error: null,
			isEditMode: true,
			originalLayerId: editingLayer.id,
		};
	}

	return {
		layerName: "",
		category: "",
		description: "",
		layerColor: "#3b82f6",
		editableBy: "creator-only",
		featureMetadata: new Map(),
		pendingFeatures: [],
		saving: false,
		error: null,
		isEditMode: false,
		originalLayerId: null,
	};
}

// ============================================================================
// Reducer
// ============================================================================

function layerEditorReducer(
	state: LayerEditorState,
	action: LayerEditorAction,
): LayerEditorState {
	switch (action.type) {
		case "INITIALIZE":
			return action.payload;

		case "SET_LAYER_NAME":
			return { ...state, layerName: action.payload, error: null };

		case "SET_CATEGORY":
			return { ...state, category: action.payload };

		case "SET_DESCRIPTION":
			return { ...state, description: action.payload };

		case "SET_LAYER_COLOR":
			return { ...state, layerColor: action.payload };

		case "SET_EDITABLE_BY":
			return { ...state, editableBy: action.payload };

		case "ADD_FEATURE_METADATA": {
			const newMetadata = new Map(state.featureMetadata);
			newMetadata.set(action.payload.id, action.payload.metadata);
			return {
				...state,
				featureMetadata: newMetadata,
				error: null,
			};
		}

		case "UPDATE_FEATURE_METADATA": {
			const newMetadata = new Map(state.featureMetadata);
			const existing = newMetadata.get(action.payload.id);
			if (existing) {
				newMetadata.set(action.payload.id, {
					...existing,
					...action.payload.updates,
				});
			}
			return {
				...state,
				featureMetadata: newMetadata,
				error: null,
			};
		}

		case "REMOVE_FEATURE_METADATA": {
			const newMetadata = new Map(state.featureMetadata);
			newMetadata.delete(action.payload);
			return {
				...state,
				featureMetadata: newMetadata,
			};
		}

		case "CLEAR_FEATURES":
			return { ...state, featureMetadata: new Map(), pendingFeatures: [] };

		case "SYNC_FROM_TERRADRAW": {
			// Create a set of feature IDs that exist in TerraDraw
			const terraDrawIds = new Set(action.payload.map((f) => String(f.id)));

			// Remove metadata for features that no longer exist in TerraDraw (were deleted)
			const newMetadata = new Map(state.featureMetadata);
			for (const featureId of newMetadata.keys()) {
				if (!terraDrawIds.has(featureId)) {
					newMetadata.delete(featureId);
				}
			}

			return { ...state, featureMetadata: newMetadata };
		}

		case "REMAP_FEATURE_IDS": {
			// When pending features are added to TerraDraw, remap their IDs
			const idMap = new Map(
				action.payload.map(({ oldId, newId }) => [oldId, newId]),
			);

			const newMetadata = new Map<string, FeatureMetadata>();

			// Transfer pending feature metadata to featureMetadata with new IDs
			for (const pending of state.pendingFeatures) {
				const newId = idMap.get(pending.id);
				if (newId) {
					newMetadata.set(newId, pending.metadata);
				}
			}

			// Keep existing metadata
			for (const [id, metadata] of state.featureMetadata) {
				newMetadata.set(id, metadata);
			}

			return {
				...state,
				featureMetadata: newMetadata,
				pendingFeatures: [], // Clear pending features after remapping
			};
		}

		case "IMPORT_GEOJSON":
			return {
				...state,
				pendingFeatures: action.payload,
				error: null,
			};

		case "CLEAR_PENDING_FEATURES":
			return { ...state, pendingFeatures: [] };

		case "SET_SAVING":
			return { ...state, saving: action.payload };

		case "SET_ERROR":
			return { ...state, error: action.payload };

		case "CLEAR_ERROR":
			return { ...state, error: null };

		case "RESET":
			return createInitialState();

		default:
			return state;
	}
}

// ============================================================================
// Helper: Merge metadata with TerraDraw snapshot to create full features
// ============================================================================

function mergeFeatures(
	featureMetadata: Map<string, FeatureMetadata>,
	terraDrawSnapshot: TerraDrawFeature[],
): Feature[] {
	const features: Feature[] = [];

	for (const terraFeature of terraDrawSnapshot) {
		const id = String(terraFeature.id);
		const metadata = featureMetadata.get(id);

		// If no metadata exists, skip this feature (it was just drawn but not named yet)
		if (!metadata) continue;

		features.push({
			id,
			type: terraFeature.geometry.type as GeometryType,
			coordinates: terraFeature.geometry.coordinates as GeoJSONCoordinates,
			name: metadata.name,
			description: metadata.description,
			icon: metadata.icon,
			lineStyle: metadata.lineStyle,
		});
	}

	return features;
}

// ============================================================================
// Hook Options
// ============================================================================

interface UseLayerEditorOptions {
	editingLayer?: Layer | null;
	terraDrawSnapshot?: TerraDrawFeature[];
	onAddFeaturesToTerraDraw?: (features: PendingFeature[]) => void;
	currentUserId?: string;
}

// ============================================================================
// Hook
// ============================================================================

export function useLayerEditor(options: UseLayerEditorOptions = {}) {
	const {
		editingLayer,
		terraDrawSnapshot,
		onAddFeaturesToTerraDraw,
		// Use authenticated user ID from Clerk, fallback to "anonymous" if not logged in
		currentUserId = "anonymous",
	} = options;

	// Track if we've initialized from editingLayer
	const initializedRef = useRef(false);
	const editingLayerIdRef = useRef<string | null>(null);

	// Initialize state based on editingLayer
	const [state, dispatch] = useReducer(
		layerEditorReducer,
		editingLayer,
		createInitialState,
	);

	// Merge metadata with TerraDraw snapshot to get full features
	const features = terraDrawSnapshot
		? mergeFeatures(state.featureMetadata, terraDrawSnapshot)
		: [];

	// Reset when editingLayer changes (different layer selected for editing)
	useEffect(() => {
		const newLayerId = editingLayer?.id || null;

		if (newLayerId !== editingLayerIdRef.current) {
			editingLayerIdRef.current = newLayerId;
			initializedRef.current = false;

			// Reinitialize state for the new layer
			const newState = createInitialState(editingLayer);
			dispatch({ type: "INITIALIZE", payload: newState });
		}
	}, [editingLayer]);

	// When editing an existing layer, add its pending features to TerraDraw
	useEffect(() => {
		if (
			!initializedRef.current &&
			state.isEditMode &&
			state.pendingFeatures.length > 0 &&
			onAddFeaturesToTerraDraw
		) {
			onAddFeaturesToTerraDraw(state.pendingFeatures);
			initializedRef.current = true;
		}
	}, [state.isEditMode, state.pendingFeatures, onAddFeaturesToTerraDraw]);

	// Sync metadata with TerraDraw snapshot (remove metadata for deleted features)
	useEffect(() => {
		if (!terraDrawSnapshot) return;

		dispatch({ type: "SYNC_FROM_TERRADRAW", payload: terraDrawSnapshot });
	}, [terraDrawSnapshot]);

	// ============================================================================
	// Actions
	// ============================================================================

	const setLayerName = useCallback((name: string) => {
		dispatch({ type: "SET_LAYER_NAME", payload: name });
	}, []);

	const setCategory = useCallback((category: string) => {
		dispatch({ type: "SET_CATEGORY", payload: category });
	}, []);

	const setDescription = useCallback((description: string) => {
		dispatch({ type: "SET_DESCRIPTION", payload: description });
	}, []);

	const setLayerColor = useCallback((color: string) => {
		dispatch({ type: "SET_LAYER_COLOR", payload: color });
	}, []);

	const setEditableBy = useCallback(
		(editableBy: "creator-only" | "everyone") => {
			dispatch({ type: "SET_EDITABLE_BY", payload: editableBy });
		},
		[],
	);

	const addFeature = useCallback(
		(terraDrawId: string | number, metadata: FeatureMetadata) => {
			const id = String(terraDrawId);
			dispatch({
				type: "ADD_FEATURE_METADATA",
				payload: { id, metadata },
			});
			return id;
		},
		[],
	);

	const updateFeature = useCallback(
		(id: string, updates: Partial<FeatureMetadata>) => {
			dispatch({ type: "UPDATE_FEATURE_METADATA", payload: { id, updates } });
		},
		[],
	);

	const removeFeature = useCallback((id: string) => {
		dispatch({ type: "REMOVE_FEATURE_METADATA", payload: id });
	}, []);

	const clearFeatures = useCallback(() => {
		dispatch({ type: "CLEAR_FEATURES" });
	}, []);

	const remapFeatureIds = useCallback(
		(idMappings: Array<{ oldId: string; newId: string }>) => {
			dispatch({ type: "REMAP_FEATURE_IDS", payload: idMappings });
		},
		[],
	);

	const importGeoJson = useCallback(
		(
			geoJsonString: string,
		): { success: boolean; error?: string; warning?: string } => {
			try {
				const geoJsonData = JSON.parse(
					geoJsonString,
				) as GeoJSONFeatureCollection;
				if (geoJsonData.type !== "FeatureCollection") {
					return {
						success: false,
						error: "Invalid GeoJSON: Must be a FeatureCollection",
					};
				}

				const pendingFeatures: PendingFeature[] = geoJsonData.features
					.map((feature, _index: number) => {
						const geometryType = feature.geometry.type;
						const coordinates = feature.geometry.coordinates;

						// Skip features with invalid coordinates
						if (!isValidCoordinates(coordinates, geometryType)) {
							return null;
						}

						return {
							id: crypto.randomUUID(),
							type: geometryType,
							coordinates,
							metadata: {
								name: feature.properties?.name || "",
								description: feature.properties?.description || "",
								icon: (feature.properties?.icon as IconType) || "default",
								lineStyle:
									(feature.properties?.lineStyle as LineStyle) || "solid",
							},
						};
					})
					.filter((f): f is PendingFeature => f !== null);

				if (pendingFeatures.length === 0) {
					return {
						success: false,
						error: "No valid features found in GeoJSON",
					};
				}

				if (pendingFeatures.length < geoJsonData.features.length) {
					// Some features were invalid but we imported what we could
					dispatch({ type: "IMPORT_GEOJSON", payload: pendingFeatures });
					return {
						success: true,
						warning: `Imported ${pendingFeatures.length} of ${geoJsonData.features.length} features (${geoJsonData.features.length - pendingFeatures.length} had invalid coordinates)`,
					};
				}

				dispatch({ type: "IMPORT_GEOJSON", payload: pendingFeatures });
				return { success: true };
			} catch (error: unknown) {
				return { success: false, error: (error as Error).message };
			}
		},
		[],
	);

	const setError = useCallback((error: string | null) => {
		dispatch({ type: "SET_ERROR", payload: error });
	}, []);

	const clearError = useCallback(() => {
		dispatch({ type: "CLEAR_ERROR" });
	}, []);

	const reset = useCallback(() => {
		initializedRef.current = false;
		editingLayerIdRef.current = null;
		dispatch({ type: "RESET" });
	}, []);

	const setSaving = useCallback((saving: boolean) => {
		dispatch({ type: "SET_SAVING", payload: saving });
	}, []);

	// ============================================================================
	// Validation
	// ============================================================================

	const validate = useCallback(
		(
			currentFeatures: Feature[],
		): {
			valid: boolean;
			error?: string;
			warning?: string;
		} => {
			if (!state.layerName.trim()) {
				return { valid: false, error: "Please enter a layer name" };
			}
			if (currentFeatures.length === 0) {
				return {
					valid: false,
					error: "Please add at least one feature to the layer",
				};
			}
			const featuresWithNames = currentFeatures.filter((f) => f.name.trim());
			if (featuresWithNames.length === 0) {
				return { valid: false, error: "Please give each feature a name" };
			}
			// Warn if some features will be skipped
			if (featuresWithNames.length < currentFeatures.length) {
				const skippedCount = currentFeatures.length - featuresWithNames.length;
				return {
					valid: true,
					warning: `${skippedCount} unnamed feature${skippedCount > 1 ? "s" : ""} will not be saved`,
				};
			}
			return { valid: true };
		},
		[state.layerName],
	);

	// ============================================================================
	// Build Layer
	// ============================================================================

	const buildLayer = useCallback(
		(
			currentFeatures: Feature[],
			editingLayerData?: Layer | null,
		): Layer | null => {
			const validation = validate(currentFeatures);
			if (!validation.valid) {
				dispatch({
					type: "SET_ERROR",
					payload: validation.error || "Validation failed",
				});
				return null;
			}

			const geoJsonFeatures: GeoJSONFeature[] = currentFeatures
				.filter((f) => f.name.trim())
				.map((feature) => ({
					type: "Feature" as const,
					properties: {
						name: feature.name,
						description: feature.description,
						featureType: feature.type,
						icon: feature.icon,
						lineStyle: feature.lineStyle,
					},
					geometry: {
						type: feature.type,
						coordinates: feature.coordinates,
					},
				}));

			const layerData: GeoJSONFeatureCollection = {
				type: "FeatureCollection",
				features: geoJsonFeatures,
			};

			return {
				id: state.originalLayerId || crypto.randomUUID(),
				name: state.layerName,
				type: "geojson",
				visible: true,
				opacity: editingLayerData?.opacity || 0.7,
				color: state.layerColor,
				data: layerData,
				legend: {
					type: "categories",
					items: [{ color: state.layerColor, label: state.layerName }],
				},
				category: state.category || undefined,
				description: state.description || undefined,
				editable: state.editableBy,
				createdBy: editingLayerData?.createdBy || currentUserId,
			};
		},
		[state, validate, currentUserId],
	);

	// ============================================================================
	// Helper methods
	// ============================================================================

	const getPendingFeatures = useCallback(() => {
		return state.pendingFeatures;
	}, [state.pendingFeatures]);

	// ============================================================================
	// Return
	// ============================================================================

	return {
		// State - explicitly listed
		layerName: state.layerName,
		category: state.category,
		description: state.description,
		layerColor: state.layerColor,
		editableBy: state.editableBy,
		features, // Merged features from metadata + TerraDraw
		pendingFeatures: state.pendingFeatures,
		saving: state.saving,
		error: state.error,
		isEditMode: state.isEditMode,
		originalLayerId: state.originalLayerId,

		// Metadata actions
		setLayerName,
		setCategory,
		setDescription,
		setLayerColor,
		setEditableBy,

		// Feature actions
		addFeature,
		updateFeature,
		removeFeature,
		clearFeatures,
		remapFeatureIds,
		importGeoJson,

		// Error handling
		setError,
		clearError,

		// Utility
		validate,
		buildLayer,
		reset,
		getPendingFeatures,

		// For saving state management
		setSaving,
	};
}

export type LayerEditorHook = ReturnType<typeof useLayerEditor>;
